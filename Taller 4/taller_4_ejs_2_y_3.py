# -*- coding: utf-8 -*-
"""Taller 4 ejs 2 y 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UstShxKw92EuGcYg-bx5S74e_bXmh_Ep
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

###############################################################################
#                             EXERCISE 2                                      #
###############################################################################
# Parámetros (en cm):
D1 = 50.0       # Distancia desde la fuente hasta las rendijas (cm)
D2 = 50.0       # Distancia desde las rendijas hasta la pantalla (cm)
lam = 6.7e-5    # Longitud de onda, 670 nm => 6.7e-5 cm
A = 0.04        # Ancho de la abertura principal, 0.4 mm => 0.04 cm
a = 0.01        # Ancho de cada rendija, 0.1 mm => 0.01 cm
d = 0.1         # Separación entre los centros de las rendijas, 0.1 cm

N = 100000      # Número de muestras aleatorias
n_z = 200       # Número de puntos en z para graficar
z_min, z_max = -0.4, 0.4  # Intervalo de z (cm)

#######################################
# 1. Generación de muestras aleatorias
#######################################
x_samples = np.random.uniform(-A/2, A/2, N)

N_half = N // 2
y_samples = np.zeros(N)

y_left_min = -d/2 - a/2
y_left_max = -d/2 + a/2
y_samples[:N_half] = np.random.uniform(y_left_min, y_left_max, N_half)

y_right_min = d/2 - a/2
y_right_max = d/2 + a/2
y_samples[N_half:] = np.random.uniform(y_right_min, y_right_max, N - N_half)

###############################################################
# 2. Cálculo de la intensidad por integral de camino de Feynman
###############################################################
z_vals = np.linspace(z_min, z_max, n_z)
intensity_path = np.zeros(n_z, dtype=np.float64)

for i, z in enumerate(z_vals):
    phase = (
        (2.0 * np.pi / lam) * (D1 + D2)
        + (np.pi / (lam * D1)) * (x_samples - y_samples)**2
        + (np.pi / (lam * D2)) * (z - y_samples)**2
    )
    amplitude_sum = np.sum(np.exp(1j * phase))
    intensity_path[i] = np.abs(amplitude_sum / N)**2

# Normalizar la intensidad
intensity_path /= np.max(intensity_path)

####################################
# 3. Cálculo del modelo clásico
####################################
def sinc(x):
    return np.where(x == 0.0, 1.0, np.sin(x)/x)

intensity_classical = np.zeros_like(z_vals)

for i, z in enumerate(z_vals):
    theta = np.arctan(z / D2)
    s = np.sin(theta)

    cos_term = np.cos((np.pi * d / lam) * s)**2
    arg_sinc = (np.pi * a / lam) * s
    sinc_term = sinc(arg_sinc)**2

    intensity_classical[i] = cos_term * sinc_term

# Normalizar la intensidad clásica
intensity_classical /= np.max(intensity_classical)

###############################
# 4. Gráfica de comparación
###############################
plt.figure(figsize=(10, 6))
plt.plot(z_vals, intensity_path, label='Integral de camino (Feynman)')
plt.plot(z_vals, intensity_classical, label='Modelo clásico (Huygens-Fresnel)', linestyle='--')
plt.xlabel('z (cm)')
plt.ylabel('Intensidad normalizada')
plt.title('Difracción en doble rendija: comparación modelo clásico vs integral de camino')
plt.legend(loc='best')

# Guardar la gráfica como PDF
plt.savefig('2.pdf')

# Mostrar la figura
plt.show()

###############################################################################
#                             EXERCISE 3                                      #
###############################################################################
N = 150       # Tamaño de la red (N x N)
J = 0.2       # Interacción de acoplamiento
beta = 10.0   # 1/(k_B * T) en unidades donde k_B = 1
frames = 500  # Número de cuadros en la animación
steps_per_frame = 400  # Número de actualizaciones de espín entre cada cuadro

# ----------------------------
# Funciones auxiliares
# ----------------------------
def inicializar_spins(N):
    """
    Devuelve una matriz N x N con valores aleatorios en {-1, 1}.
    """
    return np.random.choice([-1, 1], size=(N, N))

def delta_energia(spins, i, j, J):
    """
    Calcula el cambio de energía (ΔE) al voltear el espín (i, j),
    considerando condición de frontera periódica.
    """
    s_ij = spins[i, j]

    arriba    = spins[(i - 1) % N, j]
    abajo     = spins[(i + 1) % N, j]
    izquierda = spins[i, (j - 1) % N]
    derecha   = spins[i, (j + 1) % N]

    # ΔE = 2 * J * s_ij * (s_vecinos)
    s_vecinos = arriba + abajo + izquierda + derecha
    dE = 2.0 * J * s_ij * s_vecinos
    return dE

def metropolis_step(spins, beta, J):
    """
    Realiza una sola actualización de Metrópolis:
    - Elige un espín aleatorio
    - Calcula ΔE
    - Acepta incondicionalmente si ΔE <= 0
      o con probabilidad exp(-beta * ΔE) si ΔE > 0
    """
    i = np.random.randint(0, N)
    j = np.random.randint(0, N)
    dE = delta_energia(spins, i, j, J)

    if dE <= 0:
        spins[i, j] *= -1
    else:
        if np.random.rand() < np.exp(-beta * dE):
            spins[i, j] *= -1

# ----------------------------
# Inicialización de la red
# ----------------------------
spins = inicializar_spins(N)

# Configuración de la figura para la animación
fig, ax = plt.subplots()
im = ax.imshow(spins, vmin=-1, vmax=1, cmap='gray')
ax.set_title("Modelo de Ising 2D (Metropolis)")

# Remover ejes con valores
ax.set_xticks([])
ax.set_yticks([])

def update(frame):
    """
    Función de actualización para cada frame:
    - Realiza steps_per_frame actualizaciones de Metrópolis.
    - Actualiza la visualización.
    """
    for _ in range(steps_per_frame):
        metropolis_step(spins, beta, J)

    im.set_data(spins)
    return [im]

# Crear la animación
ani = animation.FuncAnimation(
    fig,            # Figura
    update,         # Función de actualización
    frames=frames,  # Cuántos cuadros en total
    interval=50,    # Tiempo (ms) entre cuadros
    blit=True
)

# Guardar la animación como mp4 (requiere ffmpeg instalado)
ani.save('3.mp4', writer='ffmpeg', fps=20)

# Mostrar la animación
plt.show()