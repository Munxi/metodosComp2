# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x2PRtaK7rkahCkePs0Qtl1T7q17hT4pG
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Cargar datos
file_path = '/content/list_aavso-arssn_daily.txt'
data = pd.read_csv(file_path, sep='\s+', skiprows=2, names=['Year', 'Month', 'Day', 'SSN'])

# Convertir a formato de fecha
data['Date'] = pd.to_datetime(data[['Year', 'Month', 'Day']])
data.set_index('Date', inplace=True)

# Convertir SSN a numérico y eliminar valores no válidos
data['SSN'] = pd.to_numeric(data['SSN'], errors='coerce')
data = data.dropna(subset=['SSN'])

# Obtener señal
signal = data['SSN'].values
N = len(signal)
dt = 1  # Intervalo de tiempo diario

# Calcular FFT de la señal
fft_signal = np.fft.fft(signal)

# Calcular frecuencias correspondientes a la FFT
freqs = np.fft.fftfreq(N, dt)

# Aplicar fftshift para centrar la FFT
freqs_shifted = np.fft.fftshift(freqs)
fft_signal_shifted = np.fft.fftshift(fft_signal)

# Definir el filtro gaussiano
def gaussian_filter(f, alpha):
    return np.exp(-(f * alpha)**2)

# Valores de alpha a probar
alphas = [0, 5, 10, 15, 20, 25]

# Crear figura para los subplots
fig, axs = plt.subplots(len(alphas), 2, figsize=(12, 6 * len(alphas)))

# Iterar sobre los valores de alpha
for i, alpha in enumerate(alphas):
    # Aplicar el filtro gaussiano en el dominio de la frecuencia
    filter_values = gaussian_filter(freqs, alpha)

    # Multiplicar la señal por el filtro
    filtered_signal = signal * filter_values

    # Calcular la FFT de la señal filtrada
    fft_filtered =  np.fft.fft(filtered_signal)

    # Graficar la señal original y la señal filtrada en el dominio del tiempo
    axs[i, 0].plot(data.index, signal, label='Señal original')
    axs[i, 0].plot(data.index, filtered_signal, label=f'Señal filtrada (α={alpha})')
    axs[i, 0].set_title(f'Señal en el dominio del tiempo (α={alpha})')
    axs[i, 0].legend()

    # Graficar la FFT de la señal original y de la señal filtrada (en escala logarítmica)

    #axs[i, 1].plot(freqs_shifted, np.abs(fft_signal_shifted), label='FFT señal original')
    #axs[i, 1].plot(freqs_shifted, np.abs(np.fft.fftshift(fft_filtered)), label=f'FFT señal filtrada (α={alpha})')
    axs[i, 1].semilogy(freqs_shifted, np.abs(fft_signal_shifted), label='FFT señal original')
    axs[i, 1].semilogy(freqs_shifted, np.abs(np.fft.fftshift(fft_filtered)), label=f'FFT señal filtrada (α={alpha})')
    axs[i, 1].set_title(f'FFT de la señal (α={alpha})')
    axs[i, 1].legend()
    axs[i, 1].set_xlabel('Frecuencia')
    axs[i, 1].set_ylabel('Magnitud')

plt.tight_layout()
plt.savefig('3.1.pdf')
plt.show()