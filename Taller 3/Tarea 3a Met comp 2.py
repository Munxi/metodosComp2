# -*- coding: utf-8 -*-
"""Untitled49.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nll5IN5Vqz_vie7miDuk8A2vLGWjcFv7
"""

# -*- coding: utf-8 -*-

import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from math import isclose
from scipy.integrate import solve_ivp
from scipy.optimize import brentq
import pandas as pd

# Para animación en el punto 3
from matplotlib.animation import FuncAnimation, FFMpegWriter

###############################################################################
#                             PUNTO 1: BALÍSTICA
###############################################################################
# 1. Balística con fricción cuadrática.
#   - m=10 kg, v0=10 m/s, g=9.773 m/s^2 (Bogotá).
#   - F_friccion = - beta * v * ||v||
#   - Hallar:
#       1.a) θ_max
#       1.b) ΔE perdida
#     para varios beta en [0,2).
#   - Graficar:
#       * 1.a.pdf: θ_max vs beta (escala log)
#       * 1.b.pdf: ΔE vs beta (escala log)

m = 10.0
v0 = 10.0
g = 9.773

def paso_rk4(estado, dt, beta):
    """
    Integrador RK4 para la balística con fricción.
    estado = [vx, vy, x, y]
    """
    def derivadas(s):
        vx, vy, x, y = s
        v = np.hypot(vx, vy)
        dvx = -beta * vx * v
        dvy = -g - beta * vy * v
        return np.array([dvx, dvy, vx, vy], dtype=float)

    k1 = derivadas(estado)
    k2 = derivadas(estado + 0.5*dt*k1)
    k3 = derivadas(estado + 0.5*dt*k2)
    k4 = derivadas(estado + dt*k3)

    return estado + (dt/6.0)*(k1 + 2*k2 + 2*k3 + k4)

def simular_tiro(theta, beta, dt=0.01):
    """
    Simula hasta que y < 0.
    Retorna (alcance, perdida_energia).
    """
    vx = v0*np.cos(theta)
    vy = v0*np.sin(theta)
    estado = np.array([vx, vy, 0.0, 0.0], dtype=float)

    energia_inicial = 0.5*m*(v0**2)

    while True:
        estado_previo = estado.copy()
        estado = paso_rk4(estado, dt, beta)
        if estado[3] < 0.0:
            break

    velocidad_final = np.hypot(estado[0], estado[1])
    energia_final = 0.5*m*(velocidad_final**2)
    perdida_energia = energia_inicial - energia_final

    return estado[2], perdida_energia

def encontrar_angulo_maximo(beta):
    """
    Retorna el ángulo (en grados) que maximiza el alcance.
    """
    angulos = np.linspace(0, np.pi/2, 90)
    alcances = []
    for ang in angulos:
        a, _ = simular_tiro(ang, beta)
        alcances.append(a)
    max_idx = np.argmax(alcances)
    return np.degrees(angulos[max_idx])

def punto1():
    betas = np.logspace(-3, np.log10(2), 50, endpoint=False)
    angulos_max = []
    perdidasE = []

    for beta in betas:
        th = encontrar_angulo_maximo(beta)
        angulos_max.append(th)
        _, dE = simular_tiro(np.radians(th), beta)
        perdidasE.append(dE)

    # Gráfica 1.a: θ_max vs beta
    plt.figure()
    plt.plot(betas, angulos_max, marker='o')
    plt.xscale('log')
    plt.xlabel("β (kg/m)")
    plt.ylabel("θ_max (grados)")
    plt.title("Ángulo de Alcance Máximo vs Coef. de Fricción")
    plt.grid(True)
    plt.savefig("1.a.pdf")
    plt.close()

    # Gráfica 1.b: ΔE vs beta
    plt.figure()
    plt.plot(betas, perdidasE, marker='o')
    plt.xscale('log')
    plt.xlabel("β (kg/m)")
    plt.ylabel("ΔE (J)")
    plt.title("Pérdida de Energía vs Coef. de Fricción")
    plt.grid(True)
    plt.savefig("1.b.pdf")
    plt.close()


###############################################################################
#            PUNTO 2: PARADOJA CLÁSICA (RADIACIÓN LARMOR)
###############################################################################
# 2.a) Sin Larmor
# 2.b) Con Larmor

AUT_to_attosec = 24.18884

def norm2d(v):
    return np.sqrt(v[0]**2 + v[1]**2)

def coulomb_acc(pos):
    """
    a = -r / r^3
    """
    r = norm2d(pos)
    return -pos / r**3

def rk4_step_electron(pos, vel, dt, acc_func):
    """
    Paso de RK4 para e- sin radiación.
    """
    def f(pos_, vel_):
        return acc_func(pos_)

    # k1
    k1_pos = vel
    k1_vel = f(pos, vel)

    # k2
    k2_pos = vel + 0.5*dt*k1_vel
    k2_vel = f(pos + 0.5*dt*k1_pos, vel + 0.5*dt*k1_vel)

    # k3
    k3_pos = vel + 0.5*dt*k2_vel
    k3_vel = f(pos + 0.5*dt*k2_pos, vel + 0.5*dt*k2_vel)

    # k4
    k4_pos = vel + dt*k3_vel
    k4_vel = f(pos + dt*k3_pos, vel + dt*k3_vel)

    pos_new = pos + (dt/6)*(k1_pos + 2*k2_pos + 2*k3_pos + k4_pos)
    vel_new = vel + (dt/6)*(k1_vel + 2*k2_vel + 2*k3_vel + k4_vel)

    return pos_new, vel_new

def simulate_without_larmor(dt=0.0005, tmax=30.0):
    pos = np.array([1.0, 0.0])
    vel = np.array([0.0, 1.0])

    t_vals = []
    pos_vals = []
    vel_vals = []

    t = 0.0
    while t < tmax:
        t_vals.append(t)
        pos_vals.append(pos.copy())
        vel_vals.append(vel.copy())
        pos, vel = rk4_step_electron(pos, vel, dt, coulomb_acc)
        t += dt

    return np.array(t_vals), np.array(pos_vals), np.array(vel_vals)

def find_period(t_array, pos_array):
    """
    Busca dos cruces consecutivos y=0 ascendentes.
    """
    y_vals = pos_array[:,1]
    crosses = []
    for i in range(1, len(y_vals)):
        if (y_vals[i-1] < 0) and (y_vals[i] >= 0):
            crosses.append(i)
    if len(crosses) >= 2:
        i1, i2 = crosses[0], crosses[1]
        return t_array[i2] - t_array[i1]
    return np.nan

# 2.b) Con Larmor
alpha_fina = 1/137.035999206  # c=1/alpha

def rk4_step_larmor(pos, vel, dt, acc_func):
    # Paso normal
    pos_new, vel_new = rk4_step_electron(pos, vel, dt, acc_func)
    # Aceleración
    a = norm2d(acc_func(pos_new))
    # d(v^2)/dt = -4/3 a^2 alpha^3
    delta_v2 = (4./3.)*(a**2)*(alpha_fina**3)*dt
    v_old2 = norm2d(vel)**2
    new_v2 = v_old2 - delta_v2
    if new_v2 < 0:
        new_v2 = 0
    # reescalar
    v_now2 = norm2d(vel_new)**2
    if v_now2 > 0:
        scale = np.sqrt(new_v2/v_now2)
        vel_new = vel_new*scale

    return pos_new, vel_new

def simulate_with_larmor(dt=0.0005, tmax=2000, r_collapse=0.01):
    pos = np.array([1.0, 0.0])
    vel = np.array([0.0, 1.0])

    t_vals = []
    pos_vals = []
    vel_vals = []

    t=0.0
    while t<tmax:
        r = norm2d(pos)
        if r<r_collapse:
            break
        t_vals.append(t)
        pos_vals.append(pos.copy())
        vel_vals.append(vel.copy())
        pos, vel = rk4_step_larmor(pos, vel, dt, coulomb_acc)
        t+=dt

    return np.array(t_vals), np.array(pos_vals), np.array(vel_vals)

def punto2():
    # 2.a)
    t_array, pos_array, vel_array = simulate_without_larmor()
    T_teor_au = 2*np.pi
    T_teor_as = T_teor_au*AUT_to_attosec
    T_sim_au = find_period(t_array, pos_array)
    T_sim_as = T_sim_au*AUT_to_attosec
    print(f"2.a) P_teo = {T_teor_as:.5f} as; P_sim = {T_sim_as:.5f} as")

    # 2.b)
    tL, posL, velL = simulate_with_larmor()
    if len(tL)>0:
        t_fall_au = tL[-1]
    else:
        t_fall_au=0
    t_fall_as = t_fall_au*AUT_to_attosec
    print(f"2.b) t_fall = {t_fall_as:.5f} as")

    # Graficar 2.b.XY.pdf
    plt.figure()
    plt.plot(posL[:,0], posL[:,1])
    plt.xlabel("x (a.u.)")
    plt.ylabel("y (a.u.)")
    plt.title("2.b.XY: Órbita con radiación Larmor")
    plt.grid(True)
    plt.savefig("2.b.XY.pdf")
    plt.close()

    # Diagnósticos
    r_vals = np.hypot(posL[:,0], posL[:,1])
    v_vals = np.hypot(velL[:,0], velL[:,1])
    E_kin = 0.5*(v_vals**2)
    E_tot = E_kin - 1./r_vals

    plt.figure()
    plt.plot(tL, E_tot, label="E total")
    plt.plot(tL, E_kin, label="E cinética")
    plt.plot(tL, r_vals, label="Radio")
    plt.xlabel("t (a.u.)")
    plt.legend()
    plt.title("2.b.diagnostics: Energía y radio vs tiempo")
    plt.grid(True)
    plt.savefig("2.b.diagnostics.pdf")
    plt.close()


###############################################################################
#            PUNTO 3: PRECESIÓN DE LA ÓRBITA DE MERCURIO
###############################################################################
mu = 39.4234021
alpha_real = 1.09778201e-8

a_mercurio = 0.38709893
e_mercurio = 0.20563069

x0 = a_mercurio*(1+e_mercurio)
y0 = 0.0
vx0 = 0.0
vy0 = np.sqrt((mu/a_mercurio)*((1-e_mercurio)/(1+e_mercurio)))

def ecuaciones_mercurio(t, estado, mu_, alpha_):
    x, y, vx, vy = estado
    r = np.hypot(x, y)
    if r==0:
        raise ValueError("División por cero en la órbita de Mercurio.")
    fac = - mu_/r**3 * (1 + alpha_/r**2)
    ax = fac*x
    ay = fac*y
    return [vx, vy, ax, ay]

def punto3():
    # 3.a) Efecto exagerado
    alpha_exagerado = 1e-2
    t_span = (0,10)
    t_eval = np.linspace(0,10,5000)

    sol = solve_ivp(
        ecuaciones_mercurio,
        t_span,
        [x0, y0, vx0, vy0],
        args=(mu, alpha_exagerado),
        t_eval=t_eval,
        method='RK45',
        rtol=1e-9,
        atol=1e-9
    )
    x_ = sol.y[0]
    y_ = sol.y[1]

    # Animación 3.a.mp4
    fig, ax = plt.subplots(figsize=(6,6))
    ax.set_xlim(-0.6,0.6)
    ax.set_ylim(-0.6,0.6)
    ax.set_aspect("equal")
    ax.set_title("Órbita de Mercurio (Efecto relativista exagerado)")
    ax.set_xlabel("x (UA)")
    ax.set_ylabel("y (UA)")

    sol_, = ax.plot(0,0,"yo",markersize=8,label="Sol")
    planeta, = ax.plot([],[],"ro",label="Mercurio")
    linea, = ax.plot([],[],"b-",lw=0.5,label="Trayectoria")
    ax.legend()

    def init():
        planeta.set_data([],[])
        linea.set_data([],[])
        return planeta, linea

    def actualizar(frame):
        if frame>=len(x_):
            frame=len(x_)-1
        planeta.set_data([x_[frame]], [y_[frame]])
        linea.set_data(x_[:frame+1], y_[:frame+1])
        return planeta, linea

    escritor = FFMpegWriter(fps=30, metadata={"title":"Mercurio RG Exagerado"})
    with escritor.saving(fig, "3.a.mp4", dpi=100):
        ani = FuncAnimation(fig, actualizar, frames=len(t_eval),
                            init_func=init, blit=True, interval=20)
        ani.save("3.a.mp4", writer=escritor)
    plt.close(fig)

    # 3.b) Precesión con alpha real
    def evento_perihelio(t, y, mu_, alpha_):
        # y = [x, y, vx, vy]
        # r·v= x*vx + y*vy
        x, yy, vx, vy = y
        return x*vx + yy*vy

    evento_perihelio.terminal = False
    evento_perihelio.direction = 0

    cond_iniciales = [x0, y0, vx0, vy0]

    sol2 = solve_ivp(
        ecuaciones_mercurio,
        (0,10),
        cond_iniciales,
        method="RK45",
        rtol=1e-6,
        atol=1e-9,
        max_step=1e-4,
        events=evento_perihelio,
        args=(mu, alpha_real)
    )

    t_events = sol2.t_events[0]
    x_events = sol2.y_events[0][:,0]
    y_events = sol2.y_events[0][:,1]

    # Ángulos
    angulos_r = np.arctan2(y_events, x_events)
    # Pasar a arcsec
    ang_arcsec = angulos_r*(180/np.pi)*3600

    plt.figure()
    plt.plot(t_events, ang_arcsec, "o-", label="Precesión (perihelio)")
    plt.xlabel("Tiempo (años)")
    plt.ylabel("Ángulo (arcsec)")
    plt.title("3.b) Precesión de la órbita de Mercurio")
    plt.grid(True)
    plt.legend()

    pendiente_as_año = (ang_arcsec[-1] - ang_arcsec[0])/(t_events[-1]-t_events[0])
    pendiente_as_siglo = pendiente_as_año*100
    print(f"3.b) Pendiente estimada = {pendiente_as_siglo:.4f} arcsec/siglo")

    plt.savefig("3.b.pdf")
    plt.close()


###############################################################################
#            PUNTO 4: CUANTIZACIÓN DE LA ENERGÍA
###############################################################################
def schrodinger(x, y, E):
    # y=[f, f']
    return [y[1], (x**2 - 2*E)*y[0]]

def resolver_funcion_onda(E, simetrica=True, x_max=6, num_puntos=1000):
    x_eval = np.linspace(0, x_max, num_puntos)
    if simetrica:
        y0=[1,0]
    else:
        y0=[0,1]
    sol=solve_ivp(schrodinger,(0,x_max),y0,t_eval=x_eval,args=(E,),method="RK45")
    return sol.t, sol.y[0]

def condicion_frontera(E, simetrica=True):
    _, f=resolver_funcion_onda(E,simetrica)
    return f[-1]

def encontrar_energias_permitidas(simetrica=True, n=5, rango=(0,20)):
    Es = []
    Evals = np.linspace(rango[0], rango[1], 500)
    prev = condicion_frontera(Evals[0], simetrica)
    for i in range(1,len(Evals)):
        val = condicion_frontera(Evals[i], simetrica)
        if prev*val<0:
            raiz=brentq(condicion_frontera,Evals[i-1],Evals[i],args=(simetrica,))
            Es.append(raiz)
            if len(Es)>=n:
                break
        prev=val
    return Es

def graficar_niveles_de_energia(energias,archivo="4.pdf",x_max=6,num_puntos=1000):
    x = np.linspace(-x_max,x_max,num_puntos)
    V=0.5*x**2

    plt.figure(figsize=(8,6))
    colores = plt.cm.jet(np.linspace(0,1,len(energias)))

    for i,(E,color) in enumerate(zip(energias,colores)):
        es_sim = (i%2==0)
        xp,fpos = resolver_funcion_onda(E,simetrica=es_sim,x_max=x_max,num_puntos=num_puntos)
        if es_sim:
            xfull = np.concatenate((-xp[::-1], xp))
            ffull = np.concatenate(( fpos[::-1], fpos))
        else:
            xfull = np.concatenate((-xp[::-1], xp))
            ffull = np.concatenate((-fpos[::-1], fpos))
        f_norm = ffull/np.max(np.abs(ffull))*0.4
        f_shift = f_norm+E
        plt.plot(xfull,f_shift,color=color)

    plt.plot(x, V, 'k--', label="V(x)=0.5x^2",alpha=0.5)
    plt.title("Oscilador Armónico: Niveles y Funciones de Onda")
    plt.xlabel("x")
    plt.ylabel("Energía")
    plt.grid(True,alpha=0.3)
    plt.legend()
    plt.savefig(archivo)
    plt.close()

def punto4():
    E_sim = encontrar_energias_permitidas(True,5)
    E_anti = encontrar_energias_permitidas(False,5)
    todas = sorted(E_sim+E_anti)
    graficar_niveles_de_energia(todas,"4.pdf")

    df = pd.DataFrame({
        "E_simetricas": pd.Series(E_sim),
        "E_antisimetricas": pd.Series(E_anti)
    })
    print("Energías permitidas (5 primeras en cada caso):")
    print(df.to_string(index=False))


###############################################################################
# EJECUCIÓN PRINCIPAL
###############################################################################
if __name__=="__main__":
    # Punto 1
    punto1()   # genera 1.a.pdf y 1.b.pdf

    # Punto 2
    punto2()   # imprime resultados y genera 2.b.XY.pdf y 2.b.diagnostics.pdf

    # Punto 3
    punto3()   # genera 3.a.mp4 y 3.b.pdf, e imprime la precesión hallada

    # Punto 4
    punto4()   # imprime energías y genera 4.pdf