# -*- coding: utf-8 -*-
"""Untitled49.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nll5IN5Vqz_vie7miDuk8A2vLGWjcFv7
"""

# -*- coding: utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt
from math import isclose
from scipy.integrate import solve_ivp
from scipy.optimize import brentq
import pandas as pd

# Para la animación del punto 3.a
from matplotlib.animation import FuncAnimation, FFMpegWriter

###############################################################################
#                             PUNTO 1: BALÍSTICA
###############################################################################
# 1. Balística con fricción cuadrática.
#   - Se lanza un proyectil de masa m=10 kg con v0=10 m/s, g=9.773 m/s^2 (Bogotá).
#   - Fricción: F_friccion = -v * beta * ||v||, con beta en [0, 2).
#   - Hallar:
#       1.a) Ángulo de alcance máximo theta_max
#       1.b) Energía perdida por fricción durante el vuelo
#     para varios valores de beta (usando logspace).
#   - Graficar:
#       * 1.a.pdf: theta_max vs beta (eje beta en log)
#       * 1.b.pdf: Delta_E vs beta (eje beta en log)

m = 10.0        # kg
v0 = 10.0       # m/s
g = 9.773       # m/s^2 (Bogotá)

def paso_rk4(estado, dt, beta):
    """
    Integrador de Runge-Kutta de cuarto orden (RK4) para la balística con fricción.
    estado = [vx, vy, x, y]
    beta   = coeficiente de fricción
    Retorna el nuevo estado.
    """
    def derivadas(s):
        vx, vy, x, y = s
        v = np.hypot(vx, vy)
        dvx = -beta * vx * v
        dvy = -g - beta * vy * v
        return np.array([dvx, dvy, vx, vy], dtype=float)

    k1 = derivadas(estado)
    k2 = derivadas(estado + 0.5 * dt * k1)
    k3 = derivadas(estado + 0.5 * dt * k2)
    k4 = derivadas(estado + dt * k3)

    return estado + (dt/6.0)*(k1 + 2*k2 + 2*k3 + k4)

def simular_tiro(theta, beta, dt=0.01):
    """
    Simula el proyectil hasta que toca el suelo (y<0) con resistencia cuadrática.
    Retorna (alcance, perdida_energia).
    """
    vx = v0 * np.cos(theta)
    vy = v0 * np.sin(theta)
    estado = np.array([vx, vy, 0.0, 0.0], dtype=float)

    energia_inicial = 0.5*m*(v0**2)

    while True:
        # Guardamos el anterior para el criterio de y<0 en el paso
        estado_previo = estado.copy()
        estado = paso_rk4(estado, dt, beta)
        # estado = [vx, vy, x, y]
        # Si y pasa a < 0, rompemos
        if estado[3] < 0.0:
            break

    # Ultimo estado
    velocidad_final = np.hypot(estado[0], estado[1])
    energia_final = 0.5*m*(velocidad_final**2)
    perdida_energia = energia_inicial - energia_final

    # Alcance horizontal aproximado en el último punto
    # (interpolación lineal para mayor precisión si se desea,
    #  pero no es imprescindible aquí).
    alcance = estado[2]
    return (alcance, perdida_energia)

def encontrar_angulo_maximo(beta):
    """
    Encuentra el ángulo (en grados) que maximiza el alcance, para un beta dado.
    Barrido sencillo de 0 a 90 grados (en radianes).
    """
    angulos = np.linspace(0, np.pi/2, 90)
    alcances = np.zeros_like(angulos)
    for i, ang in enumerate(angulos):
        alcances[i], _ = simular_tiro(ang, beta)
    max_idx = np.argmax(alcances)
    return np.degrees(angulos[max_idx])

def punto1():
    # Escaneo de beta en escala logarítmica [1e-3, 2)
    betas = np.logspace(-3, np.log10(2), 50, endpoint=False)
    angulos_maximos = np.zeros_like(betas)
    perdidas_energia = np.zeros_like(betas)

    for i, beta in enumerate(betas):
        theta_opt = encontrar_angulo_maximo(beta)
        angulos_maximos[i] = theta_opt
        # Luego simulamos con ese theta para hallar la pérdida de energía
        _, dE = simular_tiro(np.radians(theta_opt), beta)
        perdidas_energia[i] = dE

    # Graficar 1.a: theta_max vs beta
    plt.figure()
    plt.plot(betas, angulos_maximos, marker='o')
    plt.xscale('log')
    plt.xlabel("β (kg/m)")
    plt.ylabel("θ_max (grados)")
    plt.title("Ángulo de Alcance Máximo vs Coeficiente de Fricción")
    plt.grid(True, which="both", linestyle="--", alpha=0.7)
    plt.savefig("1.a.pdf")
    plt.close()

    # Graficar 1.b: ΔE vs beta
    plt.figure()
    plt.plot(betas, perdidas_energia, marker='o')
    plt.xscale('log')
    plt.xlabel("β (kg/m)")
    plt.ylabel("ΔE (J)")
    plt.title("Pérdida de Energía vs Coeficiente de Fricción")
    plt.grid(True, which="both", linestyle="--", alpha=0.7)
    plt.savefig("1.b.pdf")
    plt.close()


###############################################################################
#                PUNTO 2: PARADOJA CLÁSICA (RADIACIÓN LARMOR)
###############################################################################
# 2.a) Sin Larmor
#     Simula electrón (m=1 en a.u.), carga=1, en fuerza de Coulomb con protón fijo en el origen.
#     Condiciones iniciales: x=1, y=0, vx=0, vy=1 (órbita circular)
#     Período teórico T_teor = 2*pi (en unidades atómicas), que en attoseg = T_teor_as.
#     Comparamos con T_sim As.

AUT_to_attosec = 24.18884  # 1 a.u. de tiempo en attoseg

def norm2d(v):
    return np.sqrt(v[0]*v[0] + v[1]*v[1])

def coulomb_acc(pos):
    """
    Aceleración debida a la fuerza de Coulomb (unidades atómicas):
    F = - pos / r^3
    """
    r = norm2d(pos)
    return -pos / r**3

def rk4_step_electron(pos, vel, dt, acc_func):
    """
    Paso de RK4 para el electrón sin radiación.
    """
    def f(pos_, vel_):
        return acc_func(pos_)

    # k1
    k1_pos = vel
    k1_vel = f(pos, vel)

    # k2
    k2_pos = vel + 0.5*dt*k1_vel
    k2_vel = f(pos + 0.5*dt*k1_pos, vel + 0.5*dt*k1_vel)

    # k3
    k3_pos = vel + 0.5*dt*k2_vel
    k3_vel = f(pos + 0.5*dt*k2_pos, vel + 0.5*dt*k2_vel)

    # k4
    k4_pos = vel + dt*k3_vel
    k4_vel = f(pos + dt*k3_pos, vel + dt*k3_vel)

    pos_new = pos + (dt/6.0)*(k1_pos + 2*k2_pos + 2*k3_pos + k4_pos)
    vel_new = vel + (dt/6.0)*(k1_vel + 2*k2_vel + 2*k3_vel + k4_vel)

    return pos_new, vel_new

def simulate_without_larmor(dt=0.0005, tmax=30.0):
    pos = np.array([1.0, 0.0])
    vel = np.array([0.0, 1.0])

    t_list = []
    pos_list = []
    vel_list = []

    t = 0.0
    while t < tmax:
        t_list.append(t)
        pos_list.append(pos.copy())
        vel_list.append(vel.copy())
        pos, vel = rk4_step_electron(pos, vel, dt, coulomb_acc)
        t += dt

    return np.array(t_list), np.array(pos_list), np.array(vel_list)

def find_period(t_array, pos_array):
    """
    Estima el período buscando dos cruces consecutivos de y=0 con y ascendiendo.
    """
    y_vals = pos_array[:,1]
    crosses = []
    for i in range(1, len(y_vals)):
        # cruce ascendente
        if y_vals[i-1] < 0 and y_vals[i] >= 0:
            crosses.append(i)
    if len(crosses) >= 2:
        i1, i2 = crosses[0], crosses[1]
        return t_array[i2] - t_array[i1]
    else:
        return np.nan

# 2.b) Con Larmor
#    d(v^2)/dt = - (4/3) a^2 alpha^3
#    => v^2(t+dt) = v^2(t) - (4/3) a^2 alpha^3 dt
#    => luego se reescala la velocidad.

alpha_fina = 1/137.035999206  # c = 1/alpha en a.u.

def rk4_step_larmor(pos, vel, dt, acc_func):
    # Paso normal de RK4 sin radiación
    pos_new, vel_new = rk4_step_electron(pos, vel, dt, acc_func)

    # Aceleración actual (pos_new)
    a = norm2d(acc_func(pos_new))

    # Larmor: d/dt (v^2) = -4/3 a^2 alpha^3
    # (a^2)(alpha^3). alpha = 1/137 approx => alpha^3 es ~1/ (137^3).
    # En atómicas, la carga q=1 del electrón, etc.
    delta_v2 = (4.0/3.0)*(a**2)*(alpha_fina**3)*dt

    v_old2 = norm2d(vel)**2
    new_v2 = v_old2 - delta_v2
    if new_v2 < 0.0:
        new_v2 = 0.0

    # reescalar la vel final
    v_now2 = norm2d(vel_new)**2
    if v_now2 > 0.0:
        scale = np.sqrt(new_v2/v_now2)
        vel_new = vel_new * scale

    return pos_new, vel_new

def simulate_with_larmor(dt=0.0005, tmax=2000.0, r_collapse=0.01):
    pos = np.array([1.0, 0.0])
    vel = np.array([0.0, 1.0])

    t_list = []
    pos_list = []
    vel_list = []

    t = 0.0
    while t < tmax:
        r = norm2d(pos)
        if r < r_collapse:
            # Cayó
            break

        t_list.append(t)
        pos_list.append(pos.copy())
        vel_list.append(vel.copy())

        pos, vel = rk4_step_larmor(pos, vel, dt, coulomb_acc)
        t += dt

    return np.array(t_list), np.array(pos_list), np.array(vel_list)

def punto2():
    # 2.a) Sin Larmor
    dt = 0.0005
    tmax = 30.0
    t_array, pos_array, vel_array = simulate_without_larmor(dt, tmax)

    # Periodo teórico (órbita circular radio=1, velocidad=1 => T=2*pi a.u.)
    T_teor_au = 2.0*np.pi
    T_teor_as = T_teor_au * AUT_to_attosec
    # Periodo simulado
    T_sim_au = find_period(t_array, pos_array)
    T_sim_as = T_sim_au * AUT_to_attosec

    print(f"2.a) P_teo = {T_teor_as:.5f} as; P_sim = {T_sim_as:.5f} as")

    # 2.b) Con Larmor
    t_array_L, pos_array_L, vel_array_L = simulate_with_larmor(dt=0.0005, tmax=2000.0, r_collapse=0.01)

    if len(t_array_L) > 0:
        t_fall_au = t_array_L[-1]
    else:
        t_fall_au = 0.0
    t_fall_as = t_fall_au * AUT_to_attosec
    print(f"2.b) t_fall = {t_fall_as:.5f} as")

    # Graficar: 2.b.XY.pdf (órbita) y 2.b.diagnostics.pdf (Energía y radio vs t)
    # Órbita:
    plt.figure()
    plt.plot(pos_array_L[:,0], pos_array_L[:,1])
    plt.xlabel("x (a.u.)")
    plt.ylabel("y (a.u.)")
    plt.title("2.b.XY: Órbita con radiación Larmor")
    plt.grid(True)
    plt.savefig("2.b.XY.pdf")
    plt.close()

    # Diagnóstico: E (total y cinética) y radio vs tiempo
    r_vals_L = np.sqrt(pos_array_L[:,0]**2 + pos_array_L[:,1]**2)
    v_vals_L = np.sqrt(vel_array_L[:,0]**2 + vel_array_L[:,1]**2)
    E_kin_L = 0.5 * (v_vals_L**2)
    E_tot_L = E_kin_L - 1.0/r_vals_L  # Potencial -1/r

    plt.figure()
    plt.plot(t_array_L, E_tot_L, label="E total")
    plt.plot(t_array_L, E_kin_L, label="E cinética")
    plt.plot(t_array_L, r_vals_L, label="Radio")
    plt.xlabel("t (a.u.)")
    plt.legend()
    plt.title("2.b.diagnostics: Energía y radio vs tiempo")
    plt.grid(True)
    plt.savefig("2.b.diagnostics.pdf")
    plt.close()


###############################################################################
#            PUNTO 3: PRECESIÓN DE LA ÓRBITA DE MERCURIO
###############################################################################
# 3.a) Simular 10 años, con un alpha exagerado, guardar animación en 3.a.mp4
# 3.b) Repetir con alpha real, detectar perihelio, graficar ángulo vs tiempo y sacar pendiente.

mu = 39.4234021              # G*M (en UA^3 / año^2)
alpha_real = 1.09778201e-8   # término relativista (UA^2)

# Parámetros orbitales de Mercurio
a_mercurio = 0.38709893
e_mercurio = 0.20563069

x0 = a_mercurio*(1+e_mercurio)
y0 = 0.0
vx0 = 0.0
vy0 = np.sqrt((mu/a_mercurio)*((1-e_mercurio)/(1+e_mercurio)))

def ecuaciones_mercurio(t, estado, mu, alpha_):
    x, y, vx, vy = estado
    r = np.hypot(x, y)
    # Evitar r=0:
    if r == 0:
        raise ValueError("División por cero en la órbita de Mercurio.")

    factor = -mu / r**3 * (1 + alpha_ / r**2)
    ax = factor * x
    ay = factor * y
    return [vx, vy, ax, ay]

def punto3():
    # 3.a) Efecto relativista exagerado
    alpha_exagerado = 1e-2

    t_span = (0, 10)  # 10 años
    t_eval = np.linspace(t_span[0], t_span[1], 5000)

    sol = solve_ivp(ecuaciones_mercurio, t_span, [x0, y0, vx0, vy0],
                    args=(mu, alpha_exagerado), t_eval=t_eval,
                    method='RK45', rtol=1e-9, atol=1e-9)
    x_ = sol.y[0]
    y_ = sol.y[1]

    # Generar animación 3.a.mp4
    fig, ax = plt.subplots(figsize=(6, 6))
    ax.set_xlim(-0.6, 0.6)
    ax.set_ylim(-0.6, 0.6)
    ax.set_aspect('equal')
    ax.set_title('Órbita de Mercurio (Efecto relativista exagerado)')
    ax.set_xlabel('x (UA)')
    ax.set_ylabel('y (UA)')
    # Sol
    ax.plot(0, 0, 'yo', markersize=8, label='Sol')
    # Planeta
    planeta, = ax.plot([], [], 'ro', label='Mercurio')
    linea_orbita, = ax.plot([], [], 'b-', lw=0.5, label='Trayectoria')
    ax.legend()

    def init():
        planeta.set_data([], [])
        linea_orbita.set_data([], [])
        return planeta, linea_orbita

    def actualizar(frame):
        if frame >= len(x_):
            frame = len(x_) - 1
        planeta.set_data([x_[frame]], [y_[frame]])
        linea_orbita.set_data(x_[:frame+1], y_[:frame+1])
        return planeta, linea_orbita

    escritor = FFMpegWriter(fps=30, metadata={'title':'Simulación Mercurio RG Exagerado'})
    with escritor.saving(fig, "3.a.mp4", dpi=100):
        ani = FuncAnimation(fig, actualizar, frames=len(t_eval),
                            init_func=init, blit=True, interval=20)
        ani.save("3.a.mp4", writer=escritor)

    plt.close(fig)

    # 3.b) Con alpha real, detectar perihelio -> r·v=0 => x*vx + y*vy=0
    def evento_perihelio(t, y):
        x, y_, vx, vy = y
        return x*vx + y_*vy

    evento_perihelio.terminal = False
    evento_perihelio.direction = 0

    condiciones_iniciales = [x0, y0, vx0, vy0]

    sol2 = solve_ivp(ecuaciones_mercurio, (0, 10), condiciones_iniciales,
                     method='RK45', rtol=1e-6, atol=1e-9,
                     max_step=1e-4, events=evento_perihelio,
                     args=(mu, alpha_real))

    # Guardar los eventos (tiempo en que se cumple r·v=0)
    t_events = sol2.t_events[0]
    x_events = sol2.y_events[0][:,0]
    y_events = sol2.y_events[0][:,1]
    # ángulos radianes
    angulos_r = np.arctan2(y_events, x_events)

    # Ajustar ángulos en caso de estar cerca de pi, 2pi, etc.
    # (Para ver la precesión claramente)
    for i in range(len(angulos_r)):
        # Esto es un truco para normalizar
        # si angulo ~ pi, etc.
        # Ajustes suaves, depende de la implementación
        pass  # Se podría hacer un recorte condicional si se desea

    # Convertir a arcsec
    # 1 rad = (180/pi) grados, 1 grado=3600 arcsec
    angulos_arcsec = angulos_r * (180/np.pi)*3600
    # Graficar ángulo vs tiempo
    plt.figure()
    plt.plot(t_events, angulos_arcsec, 'o-', label="Precesión (perihelio)")
    plt.xlabel("Tiempo (años)")
    plt.ylabel("Ángulo (arcsec)")
    plt.title("3.b) Precesión de la órbita de Mercurio")
    plt.grid(True)
    plt.legend()

    # Calcular pendiente (arcsec/año) y luego en arcsec/siglo
    # Tomando el primer y último como referencia muy simple:
    pendiente_as_por_anio = (angulos_arcsec[-1] - angulos_arcsec[0]) / (t_events[-1] - t_events[0])
    pendiente_as_por_siglo = pendiente_as_por_anio * 100

    print(f"3.b) Pendiente estimada = {pendiente_as_por_siglo:.4f} arcsec/siglo")

    plt.savefig("3.b.pdf")
    plt.close()


###############################################################################
#            PUNTO 4: CUANTIZACIÓN DE LA ENERGÍA (Oscilador Armónico)
###############################################################################
# Ecuación de Schrödinger unidimensional (forma adimensional):
#    f''(x) = (x^2 - 2E) f(x)
# Se busca E tal que la solución no diverja en x->∞.
# Se divide en caso simétrico y antisimétrico.

from scipy.integrate import solve_ivp

def schrodinger(x, y, E):
    # y = [f, f']
    return [y[1], (x**2 - 2.0*E)*y[0]]

def resolver_funcion_onda(E, simetrica=True, x_max=6.0, num_puntos=1000):
    x_eval = np.linspace(0, x_max, num_puntos)
    if simetrica:
        y0 = [1.0, 0.0]
    else:
        y0 = [0.0, 1.0]
    sol = solve_ivp(schrodinger, (0, x_max), y0, t_eval=x_eval,
                    args=(E,), method='RK45')
    return sol.t, sol.y[0]

def condicion_de_frontera(E, simetrica=True):
    # Revisa el valor de f(x_max). Queremos que f no sea muy grande.
    # Devuelve el valor en x_max para ver el cambio de signo.
    _, f = resolver_funcion_onda(E, simetrica=simetrica)
    return f[-1]

def encontrar_energias_permitidas(simetrica=True, num_energias=5, rango_busqueda=(0, 20)):
    energias = []
    E_prueba = np.linspace(rango_busqueda[0], rango_busqueda[1], 500)
    signos = []
    for E_ in E_prueba:
        val = condicion_de_frontera(E_, simetrica)
        signos.append(val)

    for i in range(len(E_prueba)-1):
        if signos[i]*signos[i+1] < 0:
            # hay cruce de signo
            raiz_E = brentq(condicion_de_frontera, E_prueba[i], E_prueba[i+1], args=(simetrica,))
            energias.append(raiz_E)
            if len(energias) >= num_energias:
                break
    return energias

def graficar_niveles_de_energia_y_funciones_onda(energias, archivo_salida="4.pdf",
                                                 x_max=6.0, num_puntos=1000):
    """
    Graficamos las funciones de onda (simétricas y antisimétricas) sobre el potencial V = 0.5*x^2.
    """
    x = np.linspace(-x_max, x_max, num_puntos)
    V = 0.5 * x**2  # potencial armónico

    plt.figure(figsize=(8,6))
    # Generar colores
    colores = plt.cm.jet(np.linspace(0, 1, len(energias)))

    for i, (E, color) in enumerate(zip(energias, colores)):
        # simétrica si i es par, antisimétrica si i es impar (criterio)
        es_sim = (i % 2 == 0)
        x_pos, f_pos = resolver_funcion_onda(E, simetrica=es_sim, x_max=x_max, num_puntos=num_puntos)

        # Extender simétricamente
        if es_sim:
            # f( -x ) = f(x)
            x_completo = np.concatenate((-x_pos[::-1], x_pos))
            f_completo = np.concatenate((f_pos[::-1], f_pos))
        else:
            # f( -x ) = - f(x)
            x_completo = np.concatenate((-x_pos[::-1], x_pos))
            f_completo = np.concatenate((-f_pos[::-1], f_pos))

        # Escalar y desplazar la función de onda
        f_norm = f_completo / np.max(np.abs(f_completo)) * 0.4
        # Se ubica centrada en E (para visual)
        f_desplazada = f_norm + E
        plt.plot(x_completo, f_desplazada, color=color, linewidth=1.5)

    # Curva de potencial
    plt.plot(x, V, 'k--', alpha=0.5, label="V(x)=0.5*x^2")

    plt.xlabel("x")
    plt.ylabel("Energía")
    plt.title("Oscilador Armónico: Niveles de Energía y Funciones de Onda")
    plt.ylim(-0.5, max(energias)+2)
    plt.xlim(-x_max, x_max)
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.savefig(archivo_salida)
    plt.close()

def punto4():
    # Hallar 5 energías simétricas y 5 antisimétricas
    energias_simetricas = encontrar_energias_permitidas(simetrica=True, num_energias=5)
    energias_antisimetricas = encontrar_energias_permitidas(simetrica=False, num_energias=5)
    todas_energias = sorted(energias_simetricas + energias_antisimetricas)

    # Graficar todas
    graficar_niveles_de_energia_y_funciones_onda(todas_energias, archivo_salida="4.pdf")

    # Mostrar en pantalla
    df_energias = pd.DataFrame({
        "E_simetricas": pd.Series(energias_simetricas),
        "E_antisimetricas": pd.Series(energias_antisimetricas),
    })
    print("Energías permitidas (primeras 5 en cada caso):")
    print(df_energias.to_string(index=False))


###############################################################################
#                           EJECUCIÓN PRINCIPAL
###############################################################################
if __name__ == "__main__":
    # Punto 1
    punto1()  # genera 1.a.pdf y 1.b.pdf

    # Punto 2
    punto2()  # imprime 2.a) y 2.b), y genera 2.b.XY.pdf y 2.b.diagnostics.pdf

    # Punto 3
    punto3()  # genera 3.a.mp4 y 3.b.pdf, e imprime la precesión hallada

    # Punto 4
    punto4()  # genera 4.pdf y muestra en consola las energías permitidas